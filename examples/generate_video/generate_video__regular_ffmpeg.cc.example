
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libavutil/imgutils.h>
#include <libswscale/swscale.h>

int main() {
    avformat_network_init();
    
    const char* filename = "output.mp4";
    const int width = 640;
    const int height = 480;
    const int fps = 25;
    const int num_frames = 100;
    
    AVFormatContext* fmt_ctx = nullptr;
    avformat_alloc_output_context2(&fmt_ctx, nullptr, nullptr, filename);
    
    AVStream* stream = avformat_new_stream(fmt_ctx, nullptr);
    const AVCodec* codec = avcodec_find_encoder_by_name("libx264");
    
    AVCodecContext* codec_ctx = avcodec_alloc_context3(codec);
    codec_ctx->width = width;
    codec_ctx->height = height;
    codec_ctx->time_base = {1, fps};
    codec_ctx->framerate = {fps, 1};
    codec_ctx->pix_fmt = AV_PIX_FMT_YUV420P;
    codec_ctx->gop_size = 10;
    
    avcodec_open2(codec_ctx, codec, nullptr);
    avcodec_parameters_from_context(stream->codecpar, codec_ctx);
    
    avio_open(&fmt_ctx->pb, filename, AVIO_FLAG_WRITE);
    avformat_write_header(fmt_ctx, nullptr);
    
    AVFrame* frame = av_frame_alloc();
    frame->format = codec_ctx->pix_fmt;
    frame->width = codec_ctx->width;
    frame->height = codec_ctx->height;
    av_frame_get_buffer(frame, 0);
    
    AVPacket* pkt = av_packet_alloc();
    
    for (int i = 0; i < num_frames; i++) {
        av_frame_make_writable(frame);
        
        // Fill YUV frame: simple gradient
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                frame->data[0][y * frame->linesize[0] + x] = x + y + i * 3;
            }
        }
        
        for (int y = 0; y < height/2; y++) {
            for (int x = 0; x < width/2; x++) {
                frame->data[1][y * frame->linesize[1] + x] = 128 + y + i * 2;
                frame->data[2][y * frame->linesize[2] + x] = 64 + x + i * 5;
            }
        }
        
        frame->pts = i;
        
        avcodec_send_frame(codec_ctx, frame);
        while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
            av_interleaved_write_frame(fmt_ctx, pkt);
            av_packet_unref(pkt);
        }
    }
    
    // Finish encoding
    avcodec_send_frame(codec_ctx, nullptr);
    while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
        av_interleaved_write_frame(fmt_ctx, pkt);
        av_packet_unref(pkt);
    }
    
    av_write_trailer(fmt_ctx);
    
    av_frame_free(&frame);
    av_packet_free(&pkt);
    avcodec_free_context(&codec_ctx);
    avio_closep(&fmt_ctx->pb);
    avformat_free_context(fmt_ctx);
    
    return 0;
}
